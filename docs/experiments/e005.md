# E005: Odd Perfect Numbers — Constraint Filter Pipeline

```{figure} ../_static/experiments/e005_hero.png
:width: 80%
:alt: Preview figure for E005
```

**Tags:** number-theory, counterexample-search, visualization, search (see {doc}`../tags`)

## Highlights

- Apply necessary constraints as staged filters on odd candidates.
- Plot survival curves (remaining candidates per constraint stage).
- Make the “open problem” constraints tangible at finite scales.


## Goal

Demonstrate *why brute-force search for odd perfect numbers is unrealistic* by applying known
**necessary conditions** as a step-by-step filter pipeline and visualizing how the candidate pool collapses.

## Research question

Given odd integers up to a bound $N$:

- how many survive each constraint stage?
- which constraints are most “eliminating” in practice at small scales?
- what does a survival curve suggest about scalability?

## Why this qualifies as a mathematical experiment

Odd perfect numbers are an open problem. Theorems provide constraints rather than a classification.
Computation makes these constraints tangible by measuring their elimination power on finite candidate sets.

## Experiment design

### Candidate set

Start with odd integers $1 < n \le N$.

### Constraint stages (v1)

Use a conservative, well-known set of *necessary* conditions that can be checked mechanically:

1. **Euler form (shape constraint):** any odd perfect number must be of the form
   $$
   n = q^{\alpha} m^2
   $$
   where $q$ is prime, $\gcd(q,m)=1$, and
   $$
   q \equiv \alpha \equiv 1 \pmod 4.
   $$
2. **Congruence filter (Touchard-type):** odd perfect numbers satisfy strong congruence restrictions
   (implemented as one or two simple congruence checks supported by the references).
3. **Small-prime structure filters:** apply a few lightweight necessary conditions
   (e.g., reject candidates divisible by some specific small patterns if justified by the reference set).

For each stage, record “remaining candidates”.

### Output

- table: stage name, remaining count, elimination percentage
- plot: survival curve (stage index vs. remaining candidates)

## How to run

```bash
make run EXP=e005
```

or:

```bash
uv run python -m mathxlab.experiments.e005
```

## Notes / pitfalls

- Be explicit about what is *proved* vs. what is a heuristic. Only implement conditions that are truly necessary.
- At small $N$, some deep constraints won’t show their full strength; the goal is the *pipeline idea*, not a record bound.
- Euler-form testing requires factorization; keep $N$ small enough for trial division (v1).

## Extensions

- Add stronger bounds/constraints from the modern literature and compare elimination power.
- Replace trial division with an SPF sieve to scale the Euler-form test.
- Report not just counts but also the distribution of remaining prime-factor patterns.

## References

See {doc}`../references`.

{cite:p}`Voight1998PerfectNumbersElementaryIntroduction,OchemRao2014LowerBoundsOddPerfectNumbersSlides,Stone2024ImprovedUpperBoundsOddPerfectNumbersPartI,Guy2004UnsolvedProblemsInNumberTheory`
